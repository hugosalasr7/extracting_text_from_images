"""
This module includes functions that could be used to extract
 information from YouTube videos such as:
 - Download specific frames
 - Obtain the length of a video
 - Obtain the FPS of a video

Author: Hugo Salas, hsalasr7
"""

import cv2
import youtube_dl
import re
import os
import math
import multiprocessing as mp


class YouTubeInfo:
    def __init__(self, url):
        """
        Downloads the relevant information from a YouTube URL (e.g. resolution
        options available).

        Inputs:
        - url (str): URL of YouTube video
        Output:
        - (dict): Dictionary with the video's info.

        """

        ydl_opts = {}
        ydl = youtube_dl.YoutubeDL(ydl_opts)
        # If we can't extract the URLs info, we return False
        try:
            self.info = ydl.extract_info(url, download=False)

        except:
            # print('Video unavailable')
            self.info = None

    def get_sec_fps(self):

        """
        Returns a dictionary with the video's total duration and
        frames per second (FPS)

        Inputs:
        - : Object generated by youtube_info function above
        Output:
        - (dict): FPS and length (seconds) of the video

        """
        return {"FPS": self.info["fps"], "length": self.info["duration"]}

    def get_available_resolutions(self):

        """
        Returns a tuple with the resolutions available for download for
        given YouTube video.

        Inputs:
        - : Object generated by youtube_info function above
        Output:
        - (list): Resolutions available for download.

        """

        formats = self.info.get("formats", None)

        return [
            f.get("format_note", None)
            for f in formats
            if bool(re.match(".+p$", f.get("format_note", None)))
        ]

    def download_frame(
        self,
        output_path,
        output_prefix,
        parallelize=False,
        queue=None,
        process_n=None,
        frame_num=None,
        max_res=True,
        res=None,
    ):

        """
        Downloads an arbitrary frame of the YouTube video. It stores it
        as a PNG file.

        Inputs:
        - output_path: Path where the images will be saved
        - output_prefix: Prefix of the output file
        - parallelize (boolean): specifies if parallelization is taking place
        - queue: queue object (from multiprocessing module) in case
            parallelization is taking place
        - process_n: number of the process that is currently undertaking this task
        - frame_num (list): a list with the frame numbers that
            we want to download. Default is 0: first frame
            of the video
        - max_res (bool): If True, will download the image
            with the largest resolution available. Otherwise,
            will download the one with the lowest resolution.
        - res (str): Specifies the desired resolution of the PNG.
            This will override max_res.

        Output:
        - (tuple) First element is a boolean: True if it generated
            at least one png file. Second element is a list with
            all the png files it created.

        """

        # If desired frame wasn't specified, we'll download the first one only.
        if frame_num is None:
            frame_num = [0]

        if self.info is None:
            return (False, "Video NA")

        formats = self.info.get("formats", None)
        yt_res = self.get_available_resolutions()

        # Establish the target resolution
        if res is not None:
            resolution = res
        elif yt_res == []:
            return (False, "Resolution NA")
        else:
            if max_res:
                resolution = str(max([int(re.sub("p", "", x)) for x in yt_res])) + "p"
            else:
                resolution = str(min([int(re.sub("p", "", x)) for x in yt_res])) + "p"

        images_created = []

        for f in formats:
            if f.get("format_note", None) == resolution:
                url = f.get("url", None)
                cap = cv2.VideoCapture(url)

                for fnum in frame_num:
                    cap.set(1, fnum)
                    ret, frame = cap.read()
                    if ret:
                        filename = (
                            output_path
                            + output_prefix
                            + "_"
                            + resolution
                            + "_"
                            + str(fnum)
                            + "f.png"
                        )
                        images_created.append(filename)
                        cv2.imwrite(filename, frame)
                        cap.set(1, fnum)
                        if cv2.waitKey(30) & 0xFF == ord("q"):
                            break

                cap.release()

                if parallelize:
                    queue.put({"process": process_n, "rv": (True, images_created)})

                return (True, images_created)

        return (False, "Resolution NA")

    def download_many_frames(
        self,
        max_sec=None,
        min_sec=0,
        output_prefix="YT",
        diff_sec=1,
        output_path="../images/S0312",
        res="720p",
        redownload_all=False,
    ):

        """
        Downloads a sequence of frames from the YouTube video while
        parallelizing and using as many cores as possible.

        Inputs:
        - max_sec (int): Maximum second to be downloaded
        - min_sec (int): Minimum second to be downloaded
        - diff_sec (int): Difference (in seconds) between each
            of the frames to be downloaded. I.e. the sequence
            will go from min_sec to max_sec in intervals of diff_sec
        - output_path: Path where the images will be saved
        - output_prefix: Prefix of the output file
        - res (str): Specifies the desired resolution of the PNG.
        - redownload_all (bool): if True, will download all frames of
            the YouTube vid; if False, it will only download those
            frames that have not been downloaded already

        Output:
        - (list) List of strings with all of the PNGs that were
            downloaded.
        """

        # Create a folder where images will be stored
        if not os.path.exists(output_path):
            os.makedirs(output_path)

        # If no arg specified, assume max_sec is = to the video length
        if max_sec is None:
            max_sec = self.get_sec_fps()["length"]

        # Sequence of frames to be downloaded
        seq_frames = [
            self.get_sec_fps()["FPS"] * i
            for i in list(range(min_sec, max_sec))
            if i % diff_sec == 0
        ]

        if not redownload_all:
            # Only download frames that haven't been downloaded already
            already_downloaded = self.already_downloaded_frames(
                output_path=output_path, output_prefix=output_prefix, res=res
            )

            seq_frames = list(set(seq_frames) - set(already_downloaded))

        print(f"Downloading {len(seq_frames)} frames")

        if len(seq_frames) != 0:
            frames_per_core = math.ceil(len(seq_frames) / (mp.cpu_count() - 1))

            # Begin parallelization
            queue = mp.Queue()
            processes_dict = {}
            for i, val in enumerate(chunks(seq_frames, frames_per_core)):
                processes_dict[i] = mp.Process(
                    target=self.download_frame,
                    args=(
                        output_path + "/",
                        output_prefix,
                        True,
                        queue,
                        i,
                        val,
                        True,
                        res,
                    ),
                )
                processes_dict[i].start()

            for key, val in processes_dict.items():
                processes_dict[key].join()

            # Get return values back into a sorted list
            rv = [queue.get() for i in processes_dict.keys()]
            yt_images = []
            for processed_rv in sorted(rv, key=lambda i: i["process"]):
                yt_images.extend(processed_rv["rv"][1])

            print("Download complete")
            return yt_images
        else:
            print("All requested frames have already been downloaded")

    def already_downloaded_frames(self, output_path, output_prefix, res, sort=False):

        """
        Returns a list of all the PNG's that have already
        been downloaded

        Inputs:
        - output_path: Path where the images will are saved
        - output_prefix: Prefix of the PNG files
        - res (str): Specifies the downloaded resolution of the PNG.
        - sort (bool): True if output should be sorted by frame num

        Output:
        - (list) List of strings with all of the PNGs that are
            available.
        """
        already_downloaded = []
        for i in os.listdir(output_path):
            frame = re.sub(output_prefix + "_" + res + "_", "", i)
            frame = re.sub("f.png", "", frame)
            try:
                already_downloaded.append(int(frame))
            except:
                pass

        if sort:
            already_downloaded.sort()

        return already_downloaded


def chunks(lst, n):
    """Generate successive n-sized chunks from lst."""
    rv = []
    for i in range(0, len(lst), n):
        rv.append(lst[i: i + n])

    return rv
